#!/usr/bin/env ruby

require 'fileutils'
require 'open3'

require_relative 'shellconfig'

class RunCSharp
  def initialize
    @config = ShellConfig.new

    @test_formats_dir = "#{@config['FORMATS_COMPILED_DIR']}/csharp"
    @spec_dir = 'spec/csharp'
    @test_out_dir = "#{@config['TEST_OUT_DIR']}/csharp"

    #CSHARP_COMPILE_LOG_XBUILD="$CSHARP_TEST_OUT_DIR/_compile-0.log"
    #CSHARP_COMPILE_LOG_MCS_FORMATS="$CSHARP_TEST_OUT_DIR/_compile-1.log"
    #CSHARP_COMPILE_LOG_MCS_SPECS="$CSHARP_TEST_OUT_DIR/_compile-2.log"
    #CSHARP_COMPILE_LOG_XBUILD2="$CSHARP_TEST_OUT_DIR/_compile-3.log"

    detect_tools
  end

  def detect_tools
    # msbuild
    if system("msbuild /version")
      @msbuild = 'msbuild'
    elsif system("xbuild /version")
      @msbuild = 'xbuild'
    else
      raise 'Unable to find msbuild/xbuild, bailing out'
    end

    # If we're running in AppVeyor, add extra logger args
    @msbuild_args = []
    if ENV['APPVEYOR']
      @msbuild_args << '/logger:C:\Program Files\AppVeyor\BuildAgent\Appveyor.MSBuildLogger.dll'
    end

    # C# compiler
    if system("mcs --version")
      @compiler = 'mcs'
    elsif system("csc")
      @compiler = 'csc'
    end
  end

  def run
    cleanup

    # Try and build the project first - if there's no compile errors, we can continue straight away
    if build_solution('_compile-0.log').exitstatus != 0
      puts "run-csharp: some formats failed to compile, checking each file individually"
      build_cs_files_and_wipe
      if build_solution('_compile-3.log').exitstatus != 0
        raise 'Unable to build even after wipe of failing, bailing out'
      end
    end

    run_tests
  end

  def cleanup
    FileUtils::rm_rf(@test_out_dir)
    FileUtils::mkdir_p(@test_out_dir)
  end

  def build_solution(log_file)
    cli = [@msbuild] + @msbuild_args + ["#{@spec_dir}/kaitai_struct_csharp_tests.sln"]
    puts "run-csharp: running msbuild: #{cli.inspect}"
    run_and_tee({}, cli, log_file)
  end

  def build_cs_files_and_wipe
    # TODO
#	# Some formats failed to build - find the failing files and erase them
#	./travis-fold xbuild cat "$CSHARP_COMPILE_LOG_XBUILD"
#	echo "run-csharp: some formats failed to compile, checking each file individually"
#
#	# Find the invalid files and wipe them - we do this by scanning the error list from the compiler
#	mcs \
#		-t:library \
#		-fullpaths \
#		-warn:0 \
#		-r:"$CSHARP_SPEC_DIR/packages/NUnit.3.4.1/lib/net45/nunit.framework.dll" \
#		"$CSHARP_RUNTIME_DIR/*.cs" \
#		"$CSHARP_SPEC_DIR/kaitai_struct_csharp_tests/CommonSpec.cs" \
#		"$CSHARP_TEST_FORMATS_DIR"/*.cs \
#		2>&1 >"$CSHARP_COMPILE_LOG_MCS_FORMATS" | \
#		fgrep '(' | cut -d'(' -f1 | xargs -d '\n' truncate -c -s0
#
#	./travis-fold mcs_formats cat "$CSHARP_COMPILE_LOG_MCS_FORMATS"
#	echo "run-csharp: removing tests that are no longer valid"
#
#	# Now that the invalid spec classes are gone, we need to remove the matching test cases
#	mcs \
#		-t:library \
#		-fullpaths \
#		-warn:0 \
#		-r:"$CSHARP_SPEC_DIR/packages/NUnit.3.4.1/lib/net45/nunit.framework.dll" \
#		"$CSHARP_RUNTIME_DIR/*.cs" \
#		"$CSHARP_SPEC_DIR/kaitai_struct_csharp_tests/CommonSpec.cs" \
#		"$CSHARP_TEST_FORMATS_DIR"/*.cs \
#		"$CSHARP_SPEC_DIR/kaitai_struct_csharp_tests/tests/*.cs" \
#		2>&1 >"$CSHARP_COMPILE_LOG_MCS_SPECS" | \
#		fgrep '(' | cut -d'(' -f1 | xargs -d '\n' truncate -c -s0
#
#	# Invalid tests should all be gone - rebuild the project
#	./travis-fold mcs_specs cat "$CSHARP_COMPILE_LOG_MCS_FORMATS"
#	echo "run-csharp: rebuilding project"
#	xbuild "$CSHARP_SPEC_DIR/kaitai_struct_csharp_tests.sln" >"$CSHARP_COMPILE_LOG_XBUILD2"
#	./travis-fold mcs_formats cat "$CSHARP_COMPILE_LOG_XBUILD2"
  end

  def run_tests
    puts "run-csharp: running tests"

    cli = [
      "mono",
      "#{@spec_dir}/packages/NUnit.ConsoleRunner.3.4.1/tools/nunit3-console.exe",
      "--result=#{@test_out_dir}/TestResult.xml",
      "#{@spec_dir}/kaitai_struct_csharp_tests/bin/Debug/kaitai_struct_csharp_tests.dll"
    ]

    system({"CSHARP_TEST_SRC_PATH" => "src"}, *cli)
  end

  def run_and_tee(environment, cmd, stdout_file)
    exit_status = nil
    File.open(stdout_file, 'w') { |f|
      Open3.popen2e(environment, *cmd) { |stdin, out, wait_thr|
        while line = out.gets
          puts line
          f.puts line
        end
        exit_status = wait_thr.value
      }
    }
    return exit_status
  end
end

RunCSharp.new.run

#p r.run_and_tee("uname -a", '1.txt')
#p r.run_and_tee(["false", "-a"], '1.txt').exitstatus
