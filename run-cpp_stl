#!/usr/bin/env ruby

require 'fileutils'

require_relative 'shellconfig'

class RunCpp
  def initialize(src_dir, cpp_spec_dir, cpp_test_out_dir)
    @config = ShellConfig.new('config')

    @src_dir = src_dir
    @cpp_spec_dir = cpp_spec_dir
    @cpp_test_out_dir = cpp_test_out_dir

    @obj_dir = "#{@src_dir}/bin"
    @spec_cmake = "#{@obj_dir}/spec_files.cmake"
    @compiled_cmake = "#{@obj_dir}/compiled_files.cmake"
    @abs_cpp_test_out_dir = File.absolute_path(@cpp_test_out_dir)
    @test_dir = Dir.pwd
  end

  def run
    FileUtils.mkdir_p(@obj_dir)
    FileUtils.mkdir_p(@abs_cpp_test_out_dir)

    Dir.chdir(@obj_dir)

    init_file_lists
    init_cmake or raise "Failed to initialize CMake"
    build_all or raise "Failed to finish a build"
    run_tests
  end

  # Create initial list of files to compile, starting with everything
  def init_file_lists
    puts 'init_file_lists'

    init_file_list(@cpp_spec_dir, 'SPEC_SOURCES', @spec_cmake)
    init_file_list(@src_dir, 'KS_SOURCES', @compiled_cmake)
  end

  def init_file_list(dir, cmake_var, out_file)
    sources = Dir.glob("#{dir}/**/*.cpp").sort
    puts "init_file_list: #{cmake_var} in #{out_file} => #{sources.size} entries"

    File.open(out_file, 'w') { |f|
      f.puts("set(#{cmake_var}")
      sources.each { |l| f.puts(l) }
      f.puts(")")
    }
  end

  # Init CMake, generate platform-specific Makefile / project files
  def init_cmake
    puts 'init_cmake'

    cmake_cli = [
      "cmake",
      "-DCMAKE_BUILD_TYPE=Debug",
      "-DINC1_PATH=#{@spec_cmake}",
      "-DINC2_PATH=#{@compiled_cmake}",
      "-DKS_PATH=#{@src_dir}",
    ]

    # Building on Appveyor/Windows requires extra argument to CMake
    if ENV['APPVEYOR']
      cmake_cli << "-DCMAKE_TOOLCHAIN_FILE=c:/tools/vcpkg/scripts/buildsystems/vcpkg.cmake"

      arch = ENV['ARCH'] || 'x64'
      cmake_cli << "-DCMAKE_GENERATOR_PLATFORM=#{arch}"
    end

    cmake_cli << @cpp_spec_dir

    puts "cmake_cli = #{cmake_cli.inspect}"
    flush_all

    system(*cmake_cli)
  end

  def build_all
    puts "build_all"
    debug_cwd

    if compile_everything
      # all good, compile finished
      puts 'build_all: DONE'
    else
      # try to fix up by removing some files from compilation
      compile_failures_seq
      puts 'build_all: FAILED, trying to resolve by linking successfully compiled things...'
      if system("ruby", "#{@test_dir}/link-cpp_stl", ".", @abs_cpp_test_out_dir)
        puts 'build_all: DONE partially'
      else
        puts 'build_all: FAILED'
        return false
      end
    end

    return true
  end

  # Compile everything:
  # 1. KS runtime part for C++/STL
  # 2. Binary format parser sources, generated by KS compiler
  # 3. Test specs
  def compile_everything
    puts 'compile_everything: Building project generated with CMake...'
    flush_all

    if File.exists?('Makefile')
      system("LC_ALL=en_US.UTF-8 make -j8 -k >\"#{@abs_cpp_test_out_dir}/make.stdout.1\" 2>\"#{@abs_cpp_test_out_dir}/make.stderr.1\"")
    elsif File.exists?('KS_TEST_CPP_STL.sln')
      system("msbuild KS_TEST_CPP_STL.sln -fl -flp:logfile=#{@abs_cpp_test_out_dir}\\msbuild.log")
    else
      debug_cwd
      raise "No build makefile/project file found, unable to continue."
    end
  end

  def compile_failures_seq
    puts 'compile_failures_seq: Building project generated with CMake (sequentially)...'
    flush_all

    if File.exists?('Makefile')
      system("LC_ALL=en_US.UTF-8 make -k >\"#{@abs_cpp_test_out_dir}/make.stdout\" 2>\"#{@abs_cpp_test_out_dir}/make.stderr\"")
    elsif File.exists?('KS_TEST_CPP_STL.sln')
      system("msbuild KS_TEST_CPP_STL.sln -fl -flp:logfile=#{@abs_cpp_test_out_dir}\\msbuild.log")
    else
      debug_cwd
      raise "No build makefile/project file found, unable to continue"
    end
  end

  def run_tests
    puts "run_tests"

    # Work around boost v1.62 bug: https://svn.boost.org/trac10/ticket/12507
    # --log_sink is broken in boost v1.62, using workaround, as per
    # https://stackoverflow.com/a/39999085/487064
    #
    # However, Travis has boost v1.54, which has problems with it, so we
    # won't use the workaround on anything except exactly v1.62

    boost_log_option = "--log_sink=#{@abs_cpp_test_out_dir}/results.xml"

    begin
      if File.read('/usr/include/boost/version.hpp') =~ /BOOST_VERSION 106200/
        # Boost v1.62 detected, enabling workaround
        boost_log_option = "--logger=JUNIT,test_suite,#{@abs_cpp_test_out_dir}/results.xml"
      end
    rescue Errno::ENOENT => e
      # ignore
    end

    # Choose test executable
    if File.exists?("#{@obj_dir}/KS_TEST_CPP_STL.sln")
      # On Windows/MSVC, executable will be nested in Debug/
      ks_tests_bin = "#{@obj_dir}/Debug/ks_tests"
    else
      # On POSIX systems, it will be directly in obj dir
      ks_tests_bin = "#{@obj_dir}/ks_tests"
    end

    tests_cli = [
      ks_tests_bin,
      '--log_format=XML',
      boost_log_option,
      '--log_level=all',
      '--report_level=detailed',
    ]
    puts "tests_cli = #{tests_cli.inspect}"
    flush_all

    # Actually run the tests
    Dir.chdir(@test_dir)
    r = system(*tests_cli)
    flush_all

    raise "Unable to run tests" if r.nil?
  end

  def flush_all
    $stdout.flush
    $stderr.flush
  end

  def debug_cwd
    flush_all
    puts "...... Current directory: #{Dir.pwd}"
    puts "...... Current dir listing:"
    system("ls -al")
  end
end

if ARGV.size != 3
  puts "#{$PROGRAM_NAME} <src_dir> <spec_dir> <test_out_dir>"
  exit 1
end

RunCpp.new(*ARGV).run
